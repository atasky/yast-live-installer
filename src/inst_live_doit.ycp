/**
 * Maintainer:             Jiri Srain <jsrain@suse.cz>
 *
 * $Id: firstboot.ycp 36560 2007-02-28 12:40:38Z lslezak $
 */
{
textdomain "live-installer";

import "Installation";
import "Progress";
import "Wizard";
import "ImageInstallation";
import "LiveInstaller";
import "SlideShow";
import "Report";

Installation::destdir = "/mnt";

/**
 * Find symlinks which need to be resolved and copied
 * @return a list of such symlinks
 */
list<string> LinksToCopyList () {
    string cmd = sformat ("
	for LINK in `find %1 -xdev -type l` ; do
	    stat -c \"%%N\" $LINK |grep livecd >/dev/null 2>/dev/null && echo $LINK;
	done; exit 0", Installation::destdir);
    y2milestone ("Executing %1", cmd);
    map out = (map)SCR::Execute (.target.bash_output, cmd);
    y2milestone ("Result: %1", out);
    if (out["exit"]:-1 != 0)
    {
	y2error ("Faild resolving symlinks");
	return [];
    }
    string stdout = out["stdout"]:"";
    list<string> lines = splitstring (stdout, "\n");
    lines = filter (string l, lines, { return l != ""; });
    y2milestone ("Symlinks to resolve: %1", lines);
    return lines;
}

/**
 * Create a map of relevant link pointers
 * @param list of links which need to be resolved and copied
 * @return a map $[ link : target ]
 */
map<string,string> LinksMap (list<string> links) {
    integer dest_length = size (Installation::destdir);
    map<string,string> out = listmap (string link, links, {
	if (substring (link, 0, dest_length) == Installation::destdir)
	    link = substring (link, dest_length);
	if (substring (link, 0, 1) != "/")
	    link = "/" + link;
	string target = (string)SCR::Read (.target.symlink, link);
	return $[ link : target ];
    });
    y2milestone ("Resolved symlinks: %1", out);
    return out;
}

/**
 * Copy all the symlinks as needed
 * @param symlinks a map of resolved symlinks
 * @return boolean true on success
 */
boolean CopySymlinkedImage (map<string,string> symlinks, integer progress_start) {
    if (size (symlinks) == 0)
    {
	y2milestone ("No symlinked image");
	return true;
    }
    integer index = 0;
    integer progress_step = (100-progress_start) * index / size (symlinks);
    boolean ret = true;
    foreach (string link, string target, symlinks, {
	index = index + 1;
	SlideShow::StageProgress( progress_start, nil);
	SlideShow::SubProgress( 0, sformat (_("Copying %1..."), link));
	SlideShow::AppendMessageToInstLog (sformat (_("Copying %1..."), link));
//	Progress::Title (sformat (_("Copying %1..."), link));
	SCR::Execute (.target.remove, sformat ("%1/%2", Installation::destdir, link));
/*
	list<string> components = splitstring (link, "/");
	while (size(components) > 1
	    && components[size(components) - 1]:"" == "")
	{
	    components = remove (components, size (components) - 1);
	}
	if (size (components) > 1)
	    components[size(components) - 1] = "";
	link = mergestring (components, "/");
*/
	integer progress_done = progress_start + progress_step;
	ret = ImageInstallation::FileSystemCopy ("/" + target, sformat ("%1/%2", Installation::destdir, link), progress_start, progress_done) && ret;
	progress_start = progress_done;
//	Progress::Step (progress_start);
	SlideShow::StageProgress( progress_done, nil);
	SlideShow::SubProgress( 100, nil);
    });
    return ret;
}

/**
 * Copy root image to hard disk
 * @return boolean true on success
 */
boolean CopyRootImage (integer progress_start, integer progress_finish) {
    string tmpdir = (string)SCR::Read (.target.tmpdir);
    SCR::Execute (.target.bash, sformat ("/bin/cp -a %1/etc %2", Installation::destdir, tmpdir));
    boolean ret = ImageInstallation::FileSystemCopy ("/", Installation::destdir, progress_start, progress_finish);
    SCR::Execute (.target.bash, sformat ("/bin/cp -a %1/etc %2", tmpdir, Installation::destdir));
    return ret;
}
/*
Progress::New(
    // Headline for last dialog of base installation: Install LILO etc.
    _("Copying the Live Image to Hard Disk"),
    "",	// Initial progress bar label - not empty (reserve space!)
    100,
    [ _("Evaluate filesystems to copy"), _("Copy root filesystem"), _("Copy additional filesystems") ],
    [],
    "");

Wizard::DisableBackButton ();
Wizard::DisableNextButton ();

Progress::NextStage ();
Progress::Title (_("Evaluating filesystems to copy..."));
*/
SlideShow::MoveToStage( "images" );
SlideShow::StageProgress( 0, _("Evaluating filesystems to copy...") );
SlideShow::AppendMessageToInstLog (_("Evaluating filesystems to copy..."));
map<string,string> copy_map = LinksMap (LinksToCopyList ());
SlideShow::SubProgress( 0, _("Copying root filesystem..."));
SlideShow::AppendMessageToInstLog (_("Copying root filesystem..."));
SlideShow::StageProgress( 5, _("Copying live image..."));
/*
Progress::NextStageStep (5);
Progress::Title (_("Copying root filesystem..."));
*/

integer steps = size (copy_map) + 1;
integer step_size = 95 / steps;

if (! CopyRootImage (5, 5 + step_size))
{
    // error report
    Report::Error (_("Copying the live image to hard disk failed."));
    return `abort;
}
//Progress::NextStageStep (10);
if (! CopySymlinkedImage (copy_map, 5 + step_size))
{
    // error report
    Report::Error (_("Copying the live image to hard disk failed."));
    return `abort;
}
//Progress::Finish();
//Progress::Title (_("Finished."));

// reenable sources/services before their status gets stored in the target system
Pkg::SourceEditSet (LiveInstaller::source_states);
foreach (string s, map<string,any> state, LiveInstaller::service_states, {
    Pkg::ServiceSet (s, state);
    Pkg::ServiceSave (s);
});


return `next;

} // client end
